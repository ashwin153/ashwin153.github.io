---
layout:         basic
title:          "Swara"
subtitle:       "Musical machine learning"
category:       "Projects"
date:           2016-09-23 04:20:00
author:         "Ashwin Madavan"
header-img:     img/swara-bg-2.png"
---

The full code and documentation is available on [Github](https://github.com/ashwin153/swara). Cover photohraph by [Samyuktha Sridhar](http://samyusridhar.github.io).

# Introduction
[Swara](https://en.wikipedia.org/wiki/Swara) is the South Indian word for a musical note. It's an appropriate name for a musical machine learning project that attempts to imitate the legends of South Indian music, who leverage their vast and varied musical experiences to extemporaneously produce profoundly intricate sequences of swaras.

Musical machine learning is an area of active research (see, for example, [Google Magenta](https://magenta.tensorflow.org/welcome-to-magenta) and [Jukedeck](https://www.jukedeck.com/)). In this article, I'll describe my approach to the development of a variety of musical applications and the various musical and machine learning models that enable them.

# Musical Modeling
The first challenge with Swara was to develop a library, ```swara-music```, for digitally representing sheet music. The library provides a convenient representation for songs that both a programmer and musician can understand and appreciate; it enables the programmatic construction and modification of the musical elements of a song without obfuscating their underlying musical meaning. For example, a waltz tempo can be constructed using the library in the following manner.

```scala
// Waltz Tempo.
val waltz = Tempo(
  signature = Length(4, 4),
  bpm = 120.0
)
```

### Terminology
The ```swara-music``` library currently supports the following musical elements: ```Song```, ```Fragment```, ```Key```, ```Tempo```, ```Phrase```, ```Voice```, ```Chord```, ```Note```, ```Pitch```, and ```Length```. These simple musical primitives can be combined to form highly complex musical arrangements. For example, this [code](https://gist.github.com/ashwin153/d86292dbfc346b48d7e8f9e79db463fd) produces the following fragment of sheet music (rendered using [MuseScore 2](https://musescore.org/en/2.0)).

<img align="center" src="/img/sample-song.png"/>

This simple song fragment highlights some of the cool features of the ```swara-music``` library including: key and tempo changes, polyphony, multiple instruments, dynamics, and accidentals. The real beauty is in the code snippet that generated the song fragment - it reads just like music! 

### I/O
In order to facilitate interoperability, the ```swara-music``` library exposes the ```MusicReader``` and ```MusicWriter``` interfaces for writing and reading musical elements to and from various file types. The library currently supports MIDI and JSON (for python/js interoperability).

# Machine Learning
The next challenge with Swara was to develop ```swara-learn```, a library of generalized machine learning models. **Disclaimer:** this library does not pretend to compete with high-performance machine learning implementations like TensorFlow and Caffe. This library is simply the result of genuine curiosity into the inner workings of artificial intelligence.

### Discrete Markov Chain
The library includes a ```DiscreteMarkovChain``` implementation that is built off of a simple, but high-performance custom [Trie](https://en.wikipedia.org/wiki/Trie) implementation. Unlike other discrete markov chain implementations, this implementation does not require an explicit definition of the state space and the transition probabilities between states; therefore, the markov chain can simultaneously be trained and used. 

### Hidden Markov Model
A ```HiddenMarkovModel``` is a supervised learning technique that models a system in which every sequence of observations $$O_1, \ldots, O_n$$ is generated by a Markov process whose state $$H_t$$ is hidden from the observer. Hidden markov models are especially useful for sequence prediction (e.g. speech-to-text) and generation (e.g. speech generation). The implementation was designed with the following considerations in mind:

- **Unknown state space**: In many problems, the state space is not known a priori. For example, the state space of all possible chords is infinite because they may contain any number of any note; however, all songs  only ever use a finite number of distinct chords. Traditional dyamic programming algorithms like the Viterbi Algorithm require you to preallocate an $$n$$ by $$\vert H \vert$$ matrix. This is impossible if the underlying state space $$H$$ is unknown. Therefore, I was forced to use an A* variation instead.
- **Concurrency**: Implementation will be trained on massive datasets, so it would be interesting if it may be used for prediction and generation while it is trained.

### Genetic Algorithms
A genetic algorithm is an algorithm that mimics the processes of biological evolution to find optimal solutions to problems. In high school biology, we learned that when two organisms reproduce their genomes are recombined and mutated to produce offspring. Over many generations, favorable traits are naturally selected and become more predominant within a population. By mathematically defining the genetic operators that enable evolution (recombined, mutation, natural selection), we can harness the power of nature to solve arbitrary problems.

The genetic algorithm library exposes the ```Selector```, ```Mutator```, ```Evaluator```, and ```Recombinator``` traits which allow the rules of evolution to be arbitrarily defined for any problem. A ```Population``` may then be evolved according to these rules.

# Future Work
The next challenge of Swara will be to build the ```swara-core``` library, which will apply the ```swara-music``` and ```swara-learn``` libraries to build exciting musical technologies like:

- **Algorithmic Composition**: Generating original, but representative scores of music. Create a [SoundCloud Profile](https://soundcloud.com/swara-labs) with entirely computer generated content.
- **Fingerprinting**: Generating a musical fingerprint, or identifier, which uniquely define a piece of music. This fingerprint can then be used to perform musical identification and search (like Shazam).
- **Musical Translation**: Extracting musical information from audio input sources. It is the musical analogue of speech-to-text.
