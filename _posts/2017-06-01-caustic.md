---
layout:         post
title:          "Caustic"
subtitle:       "Reinventing database transactions"
category:       "Projects"
date:           2017-06-01 04:20:00
author:         "Ashwin Madavan"
header-img:     img/schema-bg.jpg"
---

The full code and documentation is available on [Github][5].

# Introduction
---
Caustic is a Scala DSL for expressing and [optimistically executing][1] database transactions. It is intended to serve as a replacement for SQL, which has reigned as the language of choice for programming database interactions for the past 43 years. As a motivating example, let's write a transaction to atomically increment a counter, ```x```, in MySQL and Caustic. In contrast with MySQL, Schema does not require an explicit table definition. Furthermore, the Schema transaction will run on *any* transactional key-value store (including MySQL). Check out the [User Guide](https://github.com/ashwin153/schema/wiki/User-Guide) for more examples of Schema in action.

```sql
CREATE TABLE `counters` (
  `key` varchar(250) NOT NULL,
  `value` BIGINT,
  PRIMARY KEY (`key`)
)

START TRANSACTION;
INSERT INTO `counters` (`key`, `value`) VALUES ("x", 1) 
ON DUPLICATE KEY UPDATE `value` = `value` + 1
COMMIT;
```

```scala
Caustic { implicit ctx =>
  val counter = Select("x")
  If (!counter.exists) {
    counter.value = 1
  } Else {
    counter.value += 1
  }
}
```

# Caustic vs. SQL
---
## Programmability or Scalability
SQL stands for "structured query language" and it is precisely the structure, or [schema][2], that SQL provides that has traditionally made relational databases so popular. While schemas provide an intuitive, organizational structure that simplifies data manipulation, they are notoriously difficult to support at scale. Large tech companies are increasingly turning towards "schema-less" key-value stores like Google's Spanner, Facebook's Cassandra, and Amazon's DynamoDB. Clearly, developers are now forced to make a conscious tradeoff between the *programmability* of a schema and the *scalability* of a NoSQL key-value store. **Why can't we have both?**

Caustic provides a dynamically-typed schema over *any* key-value store. Therefore, developers get both the usability of a relational structure and the performance of a key-value store.

## Disparate Interfaces
SQL syntax varies wildly from database to database, particularly when writing transactions. Because most of these "dialects" of SQL are not interoperable, it is extremely challenging to change the underlying database once development is under way. The tremendous expense of rewriting database queries is a significant reason why larger companies are locked into their existing database infrastructure and are unable to modernize them. **Why does the syntax of the query language have to depend on the underlying database?**

Caustic provides a *uniform* interface for expressing and executing database transactions. This means, for example, that the same transaction will work without modification on MySQL, PostgreSQL, and Cassandra.

## Deficient Functionality
SQL lacks functionality that is common to most modern programming languages. Because SQL has no concept of important constructs like conditional branching, loops, and local variables, it is extremely difficult to express programs in SQL that are relatively straightforward in other languages. This has the effect of making SQL extremely difficult to correctly write and easily maintain. **Why can't SQL be as expressive and comprehensible as other programming languages?**

Caustic's features include local variables, loops (While/For/Foreach), conditional branching (If/Else), references, secondary indices, json results, automatic memory management, and transaction rollback, many of which are difficult or impossible to express in SQL. An exhaustive enumeration of supported operations can be found in the [Appendix][3].

## Testability
Testing an application built on a SQL database is extremely expensive, because it involves costly database setup and tear down operations before and after each test run. This leads to longer build times, slower deploy queues, and reduced productivity. **Why can't SQL databases be easier to test against?**

Caustic provides out-of-box support for in-memory ```Database``` implementations that can be bootstrapped in sub-milliseconds. This dramatically reduces test times, while still guaranteeing identical functionality.

# Future Work
---
Caustic is very much a work in progress. Here are some of the ideas that are in the pipeline.

- Python, C++, Java, and Rust bindings.
- Additional database integrations (currently only MySQL and PostgreSQL).
- Distributed, transactional key-value store implementation.

Cover photograph by [Pixels Talk][4].

[1]: https://en.wikipedia.org/wiki/Optimistic_concurrency_control
[2]: https://en.wikipedia.org/wiki/Database_schema
[3]: https://github.com/ashwin153/caustic/wiki/Appendix
[4]: http://www.pixelstalk.net/wp-content/uploads/2016/11/Data-Wallpaper-for-Desktop.jpg
[5]: https://github.com/ashwin153/caustic
