---
layout:			post
title:			"Compression"
subtitle:		"Bigger isn't always better"
date:			2015-11-20 04:20:00
author:			"Ashwin Madavan"
header-img:		"img/compress-bg.png"
---

# Introduction
My compression algorithm uses curve fitting to model the bytes in a file as a **function** of their position in the file.

# Expressions
Expressions are one-dimensional functions that can be evaluated at various values in a thread-safe manner. Expressions are compositions of simpler operations like addition, multiplication, and sine. 

### Stack Expressions
Stack expressions are expressions that store their operations in reverse polish notation (RPN). RPN is a type of mathematical notation in which operations appear after their operands. For example, the expression 2+3-4 would be represented in RPN as 23+4-. The benefit of RPN is that expressions can be evaluated in a single pass without regard for order of operations using a single stack.

{% highlight java linenos %}
@Override
public BigDecimal eval() throws Exception {
	Stack<BigDecimal> stack = new Stack<BigDecimal>();
	for(int i = 0; i < _operations.size(); i++) {
		BigDecimal[] operands = new BigDecimal[_operations.get(i).arity()];
		for(int j = 0; j < operands.length; j++)
			operands[j] = stack.pop();
		stack.push(_operations.get(i).eval(operands));
	}
		
	if(stack.size() != 1) 
		throw new IllegalArgumentException("Invalid stack expression");
	return stack.pop();
}
{% endhighlight %}

### Tree Expressions
Tree expressions are expressions that store their operations in an expression tree. Each node of the expression tree represents an operation, whose inputs are the outputs of its child nodes. The image below shows the corresponding expression tree for the expression (4+3*7)-(5/(3+4))+6.

<img align="center" style="margin: 0 auto; display: block;" src="/img/compress-tree.jpg">

The most important benefit of tree expressions is that evaluation is easily parallelized; the children of any particular node can be evaluated independently. The code below parallelizes the evaluation of each node in the tree.

{% highlight java linenos %}
public BigDecimal eval(final ExecutorService executor) throws Exception {
	// Evaluates the node in parallel; we can do this because each child
	// can be evaluated independently. This should lead to a huge
	// performance boost of tree expression evaluation.
	List<Future<BigDecimal>> tasks = new ArrayList<Future<BigDecimal>>();
	for(final Node child : _children) {
		tasks.add(executor.submit(new Callable<BigDecimal>() {
			@Override
			public BigDecimal call() throws Exception {
				return child.eval(executor);
			}
		}));
	}
			
	// Retrieve the value of the future tasks and perform the operation
	BigDecimal[] inputs = new BigDecimal[_operation.arity()];
	for(int i = 0; i < inputs.length; i++)
		inputs[i] = tasks.get(i).get();
	return _operation.eval(inputs);
}
{% endhighlight %}

Another benefit of tree expressions is that they can be easily manipulated and modified by simply changing nodes in the tree. The drawbacks with tree expressions include larger memory usage.

### Testing
One of my biggest challenges was verifying that my implementation was thread-safe. The problem with testing for race conditions is that failures are non-deterministic. To eliminate the non-determinism I used a library called [MultithreadedTC](http://www.cs.umd.edu/~ayewah/projects/multithreadedtc/introduction.html) which "features a metronome that is used to provide fine control over the sequence of activities in multiple threads. The test case below utilizes MultithreadedTC to detect race conditions in a deterministic manner. 

{% highlight java linenos %}
@Test
public void testEval() throws Throwable {
	TestFramework.runManyTimes(new MultithreadedExpressionTest(), 5);
}

@SuppressWarnings({"deprecation", "unused"})
private class MultithreadedExpressionTest extends MultithreadedTestCase {
	
	private Expression _e1, _e2;
	
	@Override
	public void initialize() {
		Variable x = new Variable('x');
		_e1 = new StackExpression(x, Arrays.asList((Operation) x));
		_e2 = new TreeExpression(new StackExpression(x, Arrays.asList((Operation) x)));
	}
	
	public void thread1() throws Exception {
		assertEquals(BigDecimal.valueOf(+1), _e1.eval(BigDecimal.valueOf(+1)));
	}
	
	public void thread2() throws Exception {
		assertEquals(BigDecimal.valueOf(+2), _e2.eval(BigDecimal.valueOf(+2)));
	}
	
	public void thread3() throws Exception {
		assertEquals(BigDecimal.valueOf(+3), _e1.eval(BigDecimal.valueOf(+3)));
	}
	
	public void thread4() throws Exception {
		assertEquals(BigDecimal.valueOf(+4), _e2.eval(BigDecimal.valueOf(+4)));
	}
	
	public void thread5() throws Exception {
		int[] chunks = new int[] { 0, 1, 2, 3 };
		assertArrayEquals(chunks, _e1.eval(0, chunks.length, 1));
	}
	
	public void thread6() throws Exception {
		BigDecimal[] chunks = new BigDecimal[] { BigDecimal.ZERO, BigDecimal.ONE };
		assertArrayEquals(chunks, _e1.eval(BigDecimal.ZERO, BigDecimal.valueOf(2), BigDecimal.ONE));
	}
}
{% endhighlight %}

### Benchmarks


# Curve Fitting

### Least Squares Regression

### Discrete Fourier Regression

### Genetic Regression

# Mitigating Error

### Modified Chunking Algorithm

### Genetic Bit Weight Optimizer

# Encoding and Decoding

### Java Serialization

### Kryo Serialization

### Custom Serialization

# Results

Cover photograph by [data.gov.bc.ca](http://www.data.gov.bc.ca/local/dbc/images/feature/img_bg_slider2.png).
