---
layout:         basic-black
title:          "Caustic"
subtitle:       "Reinventing database transactions"
category:       "Projects"
date:           2017-09-14 04:20:00
author:         "Ashwin Madavan"
header-img:     "img/caustic-logo.png"
---

The full code and documentation is available on [Github][1]. Cover photograph by 
[Samyuktha Sridhar][2].

# Introduction
---
Recent years have marked an explosion in database technologies. When the sprawling Silicon Valley
software empires outgrew their relational databases, they designed specialized NoSQL systems to
store their vast troves of data. But these databases were not popularized because of their query 
languages, they were *in spite* of them. These NoSQL systems scale well be shedding functionality. 
Some like [CQL][3] and [AQL][4] try to mimic SQL, but, while they may be similar in name and intent, 
most fall short of implementing the entire SQL specification. Others like [MongoDB][5] and 
[DynamoDB][6] have their own bespoke interfaces that often are so complicated that they require
[classes][7].

Why is it that SQL, a 43 year old invention, remains the unchallenged king of query languages? To 
put that number in perspective, *Google* was founded just over 20 years ago. In that time, they have
brought the internet to our fingertips, mapped the world, and become world champions at Go.
Powering their revolutionary inventions were breathtaking advances in nearly every area of computer
science. And yet through *twice* this period SQL has reigned supreme. Maybe it's time for a change?

Caustic is a transactional programming language that interoperates with any key-value store. In this 
article, we'll explore some of the details of its implementation and the motivations behind their 
origins.

# Interoperability
---
Caustic runs on any database that implements two methods ```get``` and ```cput```. The ```get```
function is a fundamental operation in any database - it returns the corresponding values for a set
of keys. The ```cput```, or conditional put, function is slightly more sophisticated. Caustic relies
on [Multiversion Concurrency Control][8] to guarantee transactional consistency. Each value in the 
database is associated with a monotonically increasing version number, that is incremented whenever
the value is updated. A ```cput``` will change the values for a set of keys if and only if the
versions of a set of dependent keys remains unchanged.

Any database that satisfies this minimal contract, gains access to the powerful features of the
Caustic and its various infrastructrual components (like caching and clustering). In contrast, the 
SQL implementations of most databases span many tens of thousands of lines of code, and, even then, 
many are substantially lacking or incomplete. Engineers no longer need to learn a new language
(an pay for classes) every time they use a new database! 

# Programmability
---
Caustic is a fully-featured programming language, complete with constructs like loops, conditionals,
variables, and functions that have existed in modern programming languages for at least a few
decades, but still have not yet found their way into query languages. It also allows developers to
manipulate data in the more familiar idioms of procedural, imperative programming instead of the
often unintuitive language of relational algebras. Because Caustic is transactional, all programs
written in it may be distributed arbitrarily and executed concurrently without any explicit
synchronization mechanisms. Say goodbye to locks, semaphores, and race conditions!

# Examples
---
For example, the following program is a distributed counter written in Caustic. This program can be
executed without modification on *any* key value store, and run simulatenously without error on 
*any* machine. It is strongly typed and supports inheritance and polymorphism. It compiles into
executable Scala code that may be run on any JVM.

```
module caustic.example

/**
 * A total quantity.
 * 
 * @param value Current total.
 */
record Total {
  value: Integer
}

/**
 * A distributed counting service.
 */
service Counter {
  
  /**
   * Increments the total and returns the current value.
   * 
   * @param x Total reference.
   * @return Current value.
   */
  def inc(x: Total&): Integer = {
    if (x.exists) {
      x.value += 1
    } else {
      x.value = 1
    } 
  }

} 
```

[1]: https://github.com/ashwin153/caustic
[2]: https://samyusridhar.github.io/
[3]: https://docs.datastax.com/en/cql/3.1/cql/cql_intro_c.html
[4]: https://docs.arangodb.com/3.1/AQL/
[5]: https://www.mongodb.com
[6]: https://aws.amazon.com/dynamodb/
[7]: https://university.mongodb.com/
[8]: https://en.wikipedia.org/wiki/Multiversion_concurrency_control
