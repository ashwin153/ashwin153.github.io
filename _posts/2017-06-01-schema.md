---
layout:         post
title:          "Schema"
subtitle:       "Reinventing database transactions"
category:       "Projects"
date:           2017-06-01 04:20:00
author:         "Ashwin Madavan"
header-img:     img/schema-bg.jpg"
---

The full code and documentation is available on [Github](https://github.com/ashwin153/schema).

# Background
---
## What is a Schema?
A schema is an organizational structure that provides an intuitive interface for manipulating data in a relational database. Schemas are a convenient abstraction for interacting with a database, but they are incredibly challenging to support at scale. As demand for data increases, companies are increasingly turning toward "schema-less" NoSQL key-value stores like Google's Spanner, Facebook's Cassandra, and Amazon's DynamoDB. Developers are forced to make a concious tradeoff between the *useability* of a schema and the *scalability* of a key-value store.

## What is a Transaction?
### Concurrent Increment Problem
Suppose there exists some variable ```x``` that is stored in a shared database between two machines. Each machine would like to read the value of ```x```, increment it, and then write the new value back to storage. For example, the first machine might read the value of ```x``` to be ```0```, increment it to ```1```, and then write ```x = 1``` back to storage. 

Consider a situation in which the second machine reads the value of ```x``` after the first machine finishes reading but before it finishes writing. It would also read the value of ```x``` to be ```0```, increment it to ```1```, and then write ```x = 1``` back to storage. Clearly, two increments have been performed (one by the first machine, and the other by the second) but the *effect* of only one increment is recorded in the database. This behavior is incorrect, and it is a specific example of a broader class of errors called [race conditions](https://en.wikipedia.org/wiki/Race_condition). Race conditions occur whenever the ordering of a sequence of operations affects the result. 

### ACID
Databases prevent race conditions between concurrent processes using transactions. Transactions are sequences of operations that are:

- Atomic: Either all operations are applied, or none of them are.
- Consistent: Transactions see the effect of all previous transactions.
- Isolated: Concurrent execution produces deterministic behavior. 
- Durable: Committed transactions are permanent.

The [ACID](https://en.wikipedia.org/wiki/ACID) properties of transactions allow them to mitigate race conditions by guaranteeing deterministic outcomes when performing sequences of operations. For example, by *transactionally* reading, incrementing, and writing the value of ```x``` the two machines can correctly solve the concurrent increment problem described above.

### Shortcomings
While useful for preventing race conditions, database transactions are flawed, and, like all bad things, they are for three reasons.

1. Disparate Interfaces: Every database has its own language for specifying transactions, and, more often than not, these languages are not interoperable. Thus, the design of any transactional application requires an upfront knowledge of the choice of underlying database. Whenever a decision is made to change the database, all existing transactions must be rewritten to conform to the new specification. Indeed, the tremendous expense of rewriting transactions is a significant reason why large companies are locked into their existing database infrastructure and are unable to modernize them.

2. Deficient Functionality: Databases generally do not permit complex control flow like loops and conditional branches within a transaction. This makes it incredibly difficult and, sometimes, outright impossible to express relatively straightforward programs as transactions.

3. Performance Penalties: Most databases that support transactions do so at a significant cost. For example, Redis guarantees that [“All the commands in a transaction are serialized and executed sequentially. It can never happen that a request issued by another client is served in the middle of the execution of a Redis transaction. This guarantees that the commands are executed as a single isolated operation.”](https://redis.io/topics/transactions) This means that transactions may only be performed one-at-a-time, and so transactional applications may be forced to sacrifice performance for transactional safety.

# Overview
---
```Schema``` provides a runtime library for [optimistically](https://en.wikipedia.org/wiki/Optimistic_concurrency_control) executing transactions over arbitrary [transactional key-value stores](https://en.wikipedia.org/wiki/Key-value_database) and a [DSL](https://en.wikipedia.org/wiki/Domain-specific_language) for elegantly expressing transactions using a dynamically typed schema and functionality that is absent in SQL and most other transactional libraries. As a motivating example, let’s write transactions using MySQL and ```Schema``` that both solve the concurrent increment problem described above.

Notice how the MySQL transaction requires an explicit schema definition, while the ```Schema``` transaction dynamically infers this information. Furthermore, the ```Schema``` transaction is more comprehensible and interoperable - it’ll run without modification on any transactional key-value store (including MySQL).

```sql
CREATE TABLE `counters` (
  `key` varchar(250) NOT NULL,
  `value` BIGINT,
  PRIMARY KEY (`key`)
)

START TRANSACTION;
INSERT INTO `counters` (`key`, `value`) VALUES ("x", 1) 
ON DUPLICATE KEY UPDATE `value` = `value` + 1
COMMIT;
```

```scala
Schema { implicit ctx =>
  val counter = Select("x")
  If (!counter.exists) {
    counter.value = 1
  } Else {
    counter.value += 1
  }
}
```

A more thorough description of the language features can be found in the [User Guide](https://github.com/ashwin153/schema/wiki/User-Guide) and an exhaustive enumeration of supported operations can be found in the [Appendix](https://github.com/ashwin153/schema/wiki/Appendix). The [Implementation](https://github.com/ashwin153/schema/wiki/Implementation) discusses the architecture of the runtime library. Listed below are a few of the most important features of library.

- **References**: Similar to foreign keys.
- **Indices**: Similar to joins.
- **Local Variables**: Local mutable state.
- **Loops**: While/For/Foreach loops.
- **Conditional Branching**: If/Else blocks.
- **Json**: Objects may be "stitched" together into json.
- **Automatic Memory Management**: Deleting an object removes all its fields.
- **Rollback**: Transactions may be rolled back.

# Future Work
---
```Schema``` is very much a work in progress. Here are some of the ideas that are in the pipeline.

- Python, C++, Java, and Rust bindings
- Additional database integrations (currently only MySQL and PostgreSQL)
- Distributed, transactional key-value store implementation

Cover photograph by [Pixels Talk](http://www.pixelstalk.net/wp-content/uploads/2016/11/Data-Wallpaper-for-Desktop.jpg).
