<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The work and thoughts of a programmer">

    <title>Operating Systems (CS 439H) - Ashwin Madavan</title>

    <link rel="canonical" href="http://ashwin153.github.io/classes/2015/12/11/os/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

	<script type="text/javascript"
		src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>
    
	<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Ashwin Madavan</a>
       </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/">Home</a>
                </li>
                
                <li>
                    <a href="/about/">About</a>
                </li>
                
                <li>
                    <a href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header" style="background-image: url('/img/os-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Operating Systems (CS 439H)</h1>
                    
                    <h2 class="subheading">WIP: Abstraction, resource management, and frustration</h2>
                    
                    <span class="meta">Posted by Ashwin Madavan on December 11, 2015</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

				<p>What is an operating system? Operating systems are such sprawling pieces of software that most programmers interact with them without even realizing it. Operating systems serve two purposes: managing system resources and abstracting computer hardware. Their responsibilities include facilitating multi-tasking, managing memory and disk, and providing a simple interface to application programmers for interacting with hardware and system resources.</p>

<p>In this class, we built a (shitty) operating system from scratch. Beginning from just a master boot record, we designed a system capable of executing multiple c programs concurrently, complete with its own file system, system call interface, shell, and automatic reference counter. Not too bad for one semester!</p>

<h1 id="project-1-cooperative-threading">Project 1: Cooperative Threading</h1>
<p>It may seem that you are running multiple programs simultaneously on your computer; in reality, processors can only perform one task at a time. Therefore, operating systems have to execute programs in a manner that seems parallel but is actually sequential. One way of implementing interleaved execution is cooperative multitasking. A cooperative multitasking system cedes the responsibility of multiplexing user programs to the user programs themselves, who must decide when they want to <em>yield</em> to each other.</p>

<p>Our implementation of cooperative threading utilizes a simple first-in-first-out (FIFO) scheduler. The kernel maintains a ready queue of threads awaiting execution. Every time a program yields, it is placed on the end of the queue and the thread at the head of the queue is run. This procedure, known as a context switch, must first save the state of the active thread (registers, stack pointer, etc.) before switching, to ensure that the thread can pick up where it left off next time it is run. Our implementation of context switch only saves callee-saved registers (yield is a function call) and the stack pointer, but as additional features are added to our threading package we will need to save additional information in our context switch.</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="lineno"> 1</span> <span class="c"># void contextSwitch(int* oldSp, int* newSp)</span>
<span class="lineno"> 2</span> 	<span class="na">.global</span> <span class="no">contextSwitch</span>
<span class="lineno"> 3</span> <span class="nl">contextSwitch:</span>
<span class="lineno"> 4</span> 	<span class="nf">movl</span>	<span class="mi">4</span><span class="p">(</span><span class="nv">%esp</span><span class="p">),</span> <span class="nv">%eax</span>
<span class="lineno"> 5</span> 	<span class="nf">movl</span>	<span class="mi">8</span><span class="p">(</span><span class="nv">%esp</span><span class="p">),</span> <span class="nv">%ecx</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> 	<span class="c"># Push the old thread state onto the stack and save the old stack pointer</span>
<span class="lineno"> 8</span> 	<span class="nf">pushl</span>	<span class="nv">%esi</span>
<span class="lineno"> 9</span> 	<span class="nf">pushl</span>	<span class="nv">%edi</span>
<span class="lineno">10</span> 	<span class="nf">pushl</span>	<span class="nv">%ebp</span>
<span class="lineno">11</span> 	<span class="nf">pushl</span>	<span class="nv">%ebx</span>
<span class="lineno">12</span> 	<span class="nf">movl</span>	<span class="nv">%esp</span><span class="p">,</span> <span class="p">(</span><span class="nv">%eax</span><span class="p">)</span>
<span class="lineno">13</span> 	
<span class="lineno">14</span> 	<span class="c"># Retrieve the new stack pointer and pop the values off the stack</span>
<span class="lineno">15</span> 	<span class="nf">movl</span>	<span class="p">(</span><span class="nv">%ecx</span><span class="p">),</span> <span class="nv">%esp</span>
<span class="lineno">16</span> 	<span class="nf">popl</span>	<span class="nv">%ebx</span>
<span class="lineno">17</span> 	<span class="nf">popl</span>	<span class="nv">%ebp</span>
<span class="lineno">18</span> 	<span class="nf">popl</span>	<span class="nv">%edi</span>
<span class="lineno">19</span> 	<span class="nf">popl</span>	<span class="nv">%esi</span>
<span class="lineno">20</span> 	
<span class="lineno">21</span> 	<span class="nf">ret</span></code></pre></div>

<h1 id="project-2-preemptive-threading-and-memory-heap">Project 2: Preemptive Threading and Memory Heap</h1>
<p>Cooperative multitasking is a good solution if user programs are guaranteed to work together. In reality, it is unlikely that user programs will multiplex system resources efficiently and improbable that all user programs will be cooperative. Therefore, modern operating systems also implement preemptive multitasking. A preemptively multitasking system interrupts user programs at regular intervals, to ensure that all processes are given a chance to run.</p>

<p>To implement preemptive threading, we make use of interrupts, the interrupt descriptor table (IDT), and the programmable interval timer (PIT). Interrupts are triggered by hardware or software to inform the processor of some event that requires immediate attention. The processor stops what it is doing, saves its current state, locates the interrupt handler (a function) associated with the interrupt in the IDT, executes the handler, and then resumes what it was working on previously. The PIT is programmed to regularly trigger an interrupt whose interrupt handler forces the processor to perform a context switch.</p>

<p>At this point, we have a system capable of interleaving program execution. However, this system has no mechanism for preventing programs from overwriting each other’s memory and for reallocating memory. A simple solution to the first problem is a naive heap consisting of a single pointer. Each time a request to allocate memory (malloc) comes in, the naive heap returns the pointer and increments it by the number of requested bytes. However, this implementation does not solve the second problem; once a memory address has been allocated, there is no way for that address to be reused for any other purpose. Therefore, a good heap must also keep track of available blocks of memory so that blocks can be reallocated once they are no longer in use.</p>

<p><img align="center" style="margin: 0 auto; display: block;" src="/img/os-heap.png" /></p>

<p>The left image in the picture above shows the proposed design of a block. Blocks contain a header and footer that store the total size of the block, pointers to the previous and next available blocks, as well as a region where data can be stored. The sign of the header and footer indicates whether or not the block is available; if positive the block is available, and if negative the block is allocated. The right image shows what occurs when malloc is called. The heap traverses the linked list of free blocks using the next pointers and locates the first block whose total size is greater than the number of requested bytes + 8 (adjusted for heap overhead). The heap then splits the block into two pieces, updates the header and footer information of each piece, and returns a pointer to the data region of the second piece.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 2</span> 	<span class="c1">// Empty List (return 0)</span>
<span class="lineno"> 3</span> 	<span class="k">if</span><span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno"> 4</span> 
<span class="lineno"> 5</span> 	<span class="c1">// Minimum Length (16 = header + footer + 2 LL pointers)</span>
<span class="lineno"> 6</span> 	<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="n">bytes</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
<span class="lineno"> 7</span> 
<span class="lineno"> 8</span> 	<span class="c1">// First Fit (first block big enough)</span>
<span class="lineno"> 9</span> 	<span class="n">Block</span> <span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="lineno">10</span> 	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">block</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">11</span> 		<span class="k">if</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="lineno">12</span> 			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno">13</span> 		<span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="lineno">14</span> 	<span class="p">}</span>
<span class="lineno">15</span> 
<span class="lineno">16</span> 	<span class="kt">int</span> <span class="o">*</span><span class="n">header</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">block</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno">17</span> 	<span class="kt">int</span> <span class="o">*</span><span class="n">footer</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span> <span class="n">header</span> <span class="o">+</span> <span class="o">*</span><span class="n">header</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno">18</span> 
<span class="lineno">19</span> 	<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">header</span> <span class="o">-</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">20</span> 		<span class="c1">// Return Block</span>
<span class="lineno">21</span> 		<span class="n">remove</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
<span class="lineno">22</span> 		<span class="o">*</span><span class="n">header</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="lineno">23</span> 		<span class="o">*</span><span class="n">footer</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="lineno">24</span> 		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">block</span><span class="p">;</span>
<span class="lineno">25</span> 	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="lineno">26</span> 		<span class="c1">// Split Block</span>
<span class="lineno">27</span> 		<span class="o">*</span><span class="n">footer</span>  <span class="o">=</span> <span class="o">-</span><span class="n">length</span><span class="p">;</span>				<span class="c1">// New Footer</span>
<span class="lineno">28</span> 		<span class="n">footer</span>   <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span> <span class="n">footer</span> <span class="o">-</span> <span class="n">length</span><span class="p">);</span>
<span class="lineno">29</span> 		<span class="o">*</span><span class="n">footer</span>  <span class="o">=</span> <span class="o">*</span><span class="n">header</span> <span class="o">-</span> <span class="n">length</span><span class="p">;</span>			<span class="c1">// Old Footer</span>
<span class="lineno">30</span> 		<span class="o">*</span><span class="p">(</span><span class="n">footer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">length</span><span class="p">;</span>			<span class="c1">// New Header</span>
<span class="lineno">31</span> 		<span class="o">*</span><span class="p">(</span><span class="n">header</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">footer</span><span class="p">;</span>			<span class="c1">// Old Header</span>
<span class="lineno">32</span> 		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">footer</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
<span class="lineno">33</span> 	<span class="p">}</span>
<span class="lineno">34</span> <span class="p">}</span></code></pre></div>

<p>A naive implementation of free might flip the signs of the blocks header and footer and subsequently add it to the linked list of available blocks so that it can be reallocated in the future. This implementation is poor, because it could lead to memory fragmentation. To understand why, imagine a system in which a user program first allocates enough integers (4 bytes) to fill physical memory and then frees all of them. The linked list of available blocks would then contain one entry for each allocated integer. Even though no physical memory is in use, the heap will be unable to service requests for more than 4 bytes, because every block in the linked list is of size 4. A better implementation of free would merge adjacent available blocks to avoid memory fragmentation.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 2</span> 	<span class="c1">// Retrieve Block</span>
<span class="lineno"> 3</span> 	<span class="n">Block</span> <span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">Block</span><span class="o">*</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>
<span class="lineno"> 4</span> 	<span class="kt">int</span> <span class="o">*</span><span class="n">header</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">block</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno"> 5</span> 	<span class="o">*</span><span class="n">header</span>     <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="lineno"> 6</span> 	<span class="kt">int</span> <span class="o">*</span><span class="n">footer</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span> <span class="n">header</span> <span class="o">+</span> <span class="o">*</span><span class="n">header</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno"> 7</span> 	<span class="o">*</span><span class="n">footer</span>     <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="lineno"> 8</span> 
<span class="lineno"> 9</span> 	<span class="c1">// Merge Right</span>
<span class="lineno">10</span> 	<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">footer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">11</span> 		<span class="n">remove</span><span class="p">((</span><span class="n">Block</span><span class="o">*</span><span class="p">)(</span><span class="n">footer</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
<span class="lineno">12</span> 		<span class="o">*</span><span class="n">header</span> <span class="o">+=</span> <span class="o">*</span><span class="p">(</span><span class="n">footer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="lineno">13</span> 		<span class="n">footer</span>   <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span> <span class="n">header</span> <span class="o">+</span> <span class="o">*</span><span class="n">header</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno">14</span> 		<span class="o">*</span><span class="n">footer</span>  <span class="o">=</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span> 
<span class="lineno">15</span> 	<span class="p">}</span>
<span class="lineno">16</span> 
<span class="lineno">17</span> 	<span class="c1">// Merge Left</span>
<span class="lineno">18</span> 	<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">header</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">19</span> 		<span class="n">block</span> 	 <span class="o">=</span> <span class="p">(</span><span class="n">Block</span><span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span> <span class="n">block</span> <span class="o">-</span> <span class="o">*</span><span class="p">(</span><span class="n">header</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="lineno">20</span> 		<span class="n">remove</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
<span class="lineno">21</span> 		<span class="o">*</span><span class="n">footer</span> <span class="o">+=</span> <span class="o">*</span><span class="p">(</span><span class="n">header</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="lineno">22</span> 		<span class="n">header</span>   <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span> <span class="n">footer</span> <span class="o">-</span> <span class="o">*</span><span class="n">footer</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno">23</span> 		<span class="o">*</span><span class="n">header</span>  <span class="o">=</span> <span class="o">*</span><span class="n">footer</span><span class="p">;</span>
<span class="lineno">24</span> 	<span class="p">}</span>
<span class="lineno">25</span> 
<span class="lineno">26</span> 	<span class="c1">// Add Block</span>
<span class="lineno">27</span> 	<span class="n">add</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
<span class="lineno">28</span> <span class="p">}</span></code></pre></div>

<h1 id="project-3-synchronization">Project 3: Synchronization</h1>
<p>With preemption comes every programmers’ worst nightmare - race conditions. Suppose you have two threads that are both trying to flip the value of some bit. Normally, you would expect something like the following to occur.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">thread 1</th>
      <th style="text-align: center">thread 2</th>
      <th style="text-align: center">bit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">read</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">flip</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">read</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">flip</td>
      <td style="text-align: center">0</td>
    </tr>
  </tbody>
</table>

<p>Remember, threads can be preempted at <em>any</em> time. Suppose thread 1 is preempted after it has read the value, but before it flips the bit. Then, thread 2 will read the <em>old</em> value of the bit. This sequence of events produces incorrect output.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">thread 1</th>
      <th style="text-align: center">thread 2</th>
      <th style="text-align: center">bit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">read</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">read</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">flip</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">flip</td>
      <td style="text-align: center">1</td>
    </tr>
  </tbody>
</table>

<p>What can we do to prevent this problem from occurring? One way to deal with race conditions is to disable preemption within <em>critical sections</em>, or sections of code that can be executed by multiple threads or access shared resources. However, this solution is only acceptable for short critical sections, because it prevents other threads from running for the duration of the critical section. This simple solution is implemented as a <em>spin lock</em> in Linux. But what do we do for longer critical sections? How do we eliminate race conditions without preventing the rest of the system from making progress? The answer lies in the semaphore.</p>

<p>Suppose you are the cashier at a restaurant and you are helping a customer when another customer walks in. Because you can only serve one customer at a time, the customer waits in line until it is their turn to order. As customers keep coming in, they will continue to form a <em>queue</em> until you are ready to help them. Now suppose there are <em>two</em> cash registers in the restaurant, so that two customers can be served at once; customers still form a queue, but only if there are more than two of them in the restaurant. This metaphor describes the abstract behavior of a semaphore. A semaphore contains a count, a queue, and a spin lock to prevent race conditions on semaphore operations, as well as two methods: <em>down</em> and <em>up</em>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">method</th>
      <th style="text-align: left">condition</th>
      <th style="text-align: left">effect</th>
      <th style="text-align: left">analogy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">down</td>
      <td style="text-align: left">count &gt; 0</td>
      <td style="text-align: left">count decremented</td>
      <td style="text-align: left">available cashiers; so customer is immediately served</td>
    </tr>
    <tr>
      <td style="text-align: center">down</td>
      <td style="text-align: left">count == 0</td>
      <td style="text-align: left">thread added to queue</td>
      <td style="text-align: left">no available cashiers; so customer waits in line</td>
    </tr>
    <tr>
      <td style="text-align: center">up</td>
      <td style="text-align: left">queue.isEmpty()</td>
      <td style="text-align: left">count incremented</td>
      <td style="text-align: left">no waiting customers; so cashier is available/idle</td>
    </tr>
    <tr>
      <td style="text-align: center">up</td>
      <td style="text-align: left">!queue.isEmpty()</td>
      <td style="text-align: left">thread removed from queue</td>
      <td style="text-align: left">waiting customers; so next customer in line is served</td>
    </tr>
  </tbody>
</table>

<p>Below is a simple implementation of a semaphore.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno"> 1</span> <span class="k">class</span> <span class="nc">Semaphore</span> <span class="p">{</span>
<span class="lineno"> 2</span> 	<span class="kt">uint32_t</span> <span class="n">count</span><span class="p">;</span>
<span class="lineno"> 3</span> 	<span class="n">SpinLock</span> <span class="o">*</span><span class="n">spin</span><span class="p">;</span>
<span class="lineno"> 4</span> 	<span class="n">SimpleQueue</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
<span class="lineno"> 5</span> 
<span class="lineno"> 6</span> <span class="k">public</span><span class="o">:</span>
<span class="lineno"> 7</span>     <span class="n">Semaphore</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">count</span><span class="p">)</span> <span class="o">:</span> <span class="n">count</span><span class="p">(</span><span class="n">count</span><span class="p">),</span> 
<span class="lineno"> 8</span> 		<span class="n">spin</span><span class="p">(</span><span class="k">new</span> <span class="n">SpinLock</span><span class="p">()),</span> <span class="n">queue</span><span class="p">(</span><span class="k">new</span> <span class="n">SimpleQueue</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{}</span>
<span class="lineno"> 9</span> 	
<span class="lineno">10</span>     <span class="kt">void</span> <span class="n">down</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">11</span> 		<span class="c1">// Lock the semaphore</span>
<span class="lineno">12</span> 		<span class="kt">bool</span> <span class="n">was</span> <span class="o">=</span> <span class="n">spin</span> <span class="o">-&gt;</span> <span class="n">lock</span><span class="p">();</span>
<span class="lineno">13</span> 
<span class="lineno">14</span> 		<span class="c1">// If not at capacity, then decrement and unlock. Otherwise, add </span>
<span class="lineno">15</span> 		<span class="c1">// the thread to the blocked queue and remove it from the ready queue.</span>
<span class="lineno">16</span> 		<span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">17</span> 			<span class="n">count</span><span class="o">--</span><span class="p">;</span>
<span class="lineno">18</span> 			<span class="n">spin</span> <span class="o">-&gt;</span> <span class="n">unlock</span><span class="p">(</span><span class="n">was</span><span class="p">);</span>
<span class="lineno">19</span> 		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="lineno">20</span> 			<span class="n">queue</span> <span class="o">-&gt;</span> <span class="n">add</span><span class="p">(</span><span class="n">Thread</span><span class="o">::</span><span class="n">current</span><span class="p">());</span>
<span class="lineno">21</span> 			<span class="n">threadBlock</span><span class="p">(</span><span class="n">spin</span><span class="p">,</span> <span class="n">was</span><span class="p">);</span>
<span class="lineno">22</span> 		<span class="p">}</span>
<span class="lineno">23</span> 	<span class="p">}</span>
<span class="lineno">24</span> 
<span class="lineno">25</span>     <span class="kt">void</span> <span class="n">up</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">26</span> 		<span class="c1">// Lock the semaphore</span>
<span class="lineno">27</span> 		<span class="kt">bool</span> <span class="n">was</span> <span class="o">=</span> <span class="n">spin</span> <span class="o">-&gt;</span> <span class="n">lock</span><span class="p">();</span>
<span class="lineno">28</span> 
<span class="lineno">29</span> 		<span class="c1">// If there are no blocked threads, then increment the counter and</span>
<span class="lineno">30</span> 		<span class="c1">// continue execution. Otherwise, retrieve the next waiting thread</span>
<span class="lineno">31</span> 		<span class="c1">// from the blocked queue and add it to the ready queue.</span>
<span class="lineno">32</span> 		<span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">33</span> 			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="lineno">34</span> 		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="lineno">35</span> 			<span class="c1">// If the blocked threads queue is empty, then increment the</span>
<span class="lineno">36</span> 			<span class="c1">// counter and continue execution. Otherwise, add the thread</span>
<span class="lineno">37</span> 			<span class="c1">// to the ready queue and do not increment the counter.</span>
<span class="lineno">38</span> 			<span class="n">Thread</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">queue</span> <span class="o">-&gt;</span> <span class="n">remove</span><span class="p">();</span>
<span class="lineno">39</span> 			<span class="k">if</span><span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">40</span> 				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="lineno">41</span> 			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="lineno">42</span> 				<span class="n">threadReady</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
<span class="lineno">43</span> 			<span class="p">}</span>
<span class="lineno">44</span> 		<span class="p">}</span>
<span class="lineno">45</span> 
<span class="lineno">46</span> 		<span class="c1">// Unlock the semaphore</span>
<span class="lineno">47</span> 		<span class="n">spin</span> <span class="o">-&gt;</span> <span class="n">unlock</span><span class="p">(</span><span class="n">was</span><span class="p">);</span>	
<span class="lineno">48</span> 	<span class="p">}</span>
<span class="lineno">49</span> <span class="p">};</span></code></pre></div>

<p>Another interesting problem in concurrency is the Producer-Consumer Problem. Suppose you have two threads and a shared buffer of finite size. The first thread is attempting to <em>put</em> elements in the buffer (producer) and the second thread is attempting to <em>remove</em> elements from the buffer (consumer). How do we ensure that the producer only places elements in the buffer when it is not full, and the consumer only removes elements from the buffer when it is not empty? The solution to this problem is to use bounded buffers, which make clever use of semaphores to ensure that the producer waits until there is free space in the buffer and the consumer waits until there is data in the buffer. My implementation of bounded buffers utilizes a circular array, two semaphores, and a mutex to solve the producer-consumer problem.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno"> 1</span> <span class="k">class</span> <span class="nc">BoundedBuffer</span> <span class="p">{</span>
<span class="lineno"> 2</span> 	<span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="lineno"> 3</span> 	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>	
<span class="lineno"> 4</span> 	<span class="kt">int</span> <span class="n">pindex</span><span class="p">;</span>
<span class="lineno"> 5</span> 	<span class="kt">int</span> <span class="n">gindex</span><span class="p">;</span>
<span class="lineno"> 6</span> 	
<span class="lineno"> 7</span> 	<span class="n">Semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">;</span>
<span class="lineno"> 8</span> 	<span class="n">Semaphore</span> <span class="o">*</span><span class="n">put</span><span class="p">;</span>
<span class="lineno"> 9</span> 	<span class="n">Semaphore</span> <span class="o">*</span><span class="n">get</span><span class="p">;</span>
<span class="lineno">10</span> 
<span class="lineno">11</span> <span class="k">public</span><span class="o">:</span>
<span class="lineno">12</span>     <span class="n">BoundedBuffer</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">pindex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">gindex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">13</span> 		<span class="n">sem</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="lineno">14</span> 		<span class="n">put</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="lineno">15</span> 		<span class="n">get</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="lineno">16</span> 	<span class="p">}</span>   		
<span class="lineno">17</span> 
<span class="lineno">18</span>     <span class="kt">void</span> <span class="n">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">19</span> 		<span class="c1">// Down the put semaphore; block until there is space available.</span>
<span class="lineno">20</span> 		<span class="n">put</span> <span class="o">-&gt;</span> <span class="n">down</span><span class="p">();</span>
<span class="lineno">21</span> 
<span class="lineno">22</span> 		<span class="c1">// This semaphore acts as a mutex to prevent multiple threads from </span>
<span class="lineno">23</span> 		<span class="c1">// interacting with the buffer at once.</span>
<span class="lineno">24</span> 		<span class="n">sem</span> <span class="o">-&gt;</span> <span class="n">down</span><span class="p">();</span>		
<span class="lineno">25</span> 
<span class="lineno">26</span> 		<span class="c1">// Add the value and adjust the pointer</span>
<span class="lineno">27</span> 		<span class="n">data</span><span class="p">[</span><span class="n">pindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="lineno">28</span> 		<span class="n">pindex</span> <span class="o">=</span> <span class="p">(</span><span class="n">pindex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
<span class="lineno">29</span> 
<span class="lineno">30</span> 		<span class="c1">// Unlock the mutex to allow other threads to use buffer</span>
<span class="lineno">31</span> 		<span class="n">sem</span> <span class="o">-&gt;</span> <span class="n">up</span><span class="p">();</span>
<span class="lineno">32</span> 
<span class="lineno">33</span> 		<span class="c1">// Up the get semaphore to indicate that data is available to be read.</span>
<span class="lineno">34</span> 		<span class="n">get</span> <span class="o">-&gt;</span> <span class="n">up</span><span class="p">();</span>	
<span class="lineno">35</span> 	<span class="p">}</span> 
<span class="lineno">36</span> 
<span class="lineno">37</span>     <span class="kt">int</span> <span class="n">get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">38</span> 		<span class="c1">// Down the get semaphore; block until there are elements to be read.</span>
<span class="lineno">39</span> 		<span class="n">get</span> <span class="o">-&gt;</span> <span class="n">down</span><span class="p">();</span>
<span class="lineno">40</span> 
<span class="lineno">41</span> 		<span class="c1">// Lock the buffer to prevent race conditions.</span>
<span class="lineno">42</span> 		<span class="n">sem</span> <span class="o">-&gt;</span> <span class="n">down</span><span class="p">();</span>
<span class="lineno">43</span> 
<span class="lineno">44</span> 		<span class="c1">// Retrieve the next element in the buffer.</span>
<span class="lineno">45</span> 		<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">gindex</span><span class="p">];</span>
<span class="lineno">46</span> 		<span class="n">gindex</span> <span class="o">=</span> <span class="p">(</span><span class="n">gindex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
<span class="lineno">47</span> 		
<span class="lineno">48</span> 		<span class="c1">// Unlock the buffer</span>
<span class="lineno">49</span> 		<span class="n">sem</span> <span class="o">-&gt;</span> <span class="n">up</span><span class="p">();</span>
<span class="lineno">50</span> 
<span class="lineno">51</span> 		<span class="c1">// Up the put semaphore to indicate that there is available space.</span>
<span class="lineno">52</span> 		<span class="n">put</span> <span class="o">-&gt;</span> <span class="n">up</span><span class="p">();</span>
<span class="lineno">53</span> 
<span class="lineno">54</span> 		<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="lineno">55</span>     <span class="p">}</span>
<span class="lineno">56</span> 
<span class="lineno">57</span> <span class="p">};</span></code></pre></div>

<p>In addition to these synchronization mechanisms, we also built events and barriers. Threads can <em>wait</em> on events, and when another thread <em>signals</em> that the event is complete, the waiting threads resumes execution. Barriers force threads to wait until a set number of threads reach the barrier. These synchronization techniques will become useful later on when we start developing more complicated abstractions.</p>

<h1 id="project-4-reference-counting">Project 4: Reference Counting</h1>
<p>We now have a system capable of two forms of multithreading, complete with its own heap as well as an assortment of synchronization mechanisms to eliminate pesky race conditions and facilitate parallelized computation.</p>

<p>The next problem we have to consider is memory leaks. How do we ensure that objects are destructed when they go out of scope? There are three places where an object can live: on the stack, in the heap, or in global memory. However, it is trivial to detect when stack-allocated objects go out of scope (when they are popped off the stack) and global objects <em>never</em> go out of scope (definition of global). Therefore, the real challenge is detecting when heap-allocated objects should be destructed.</p>

<p>We discussed two solutions for managing heap-allocated objects: tracing garbage collection and automatic reference counting. Tracing garbage collection takes an active approach to memory management; for example, the mark-and-sweep garbage collector looks through the stack frames and global memory of all running threads, marks all referenced objects within the heap, and then scans through the heap and frees all unmarked objects. In contrast, an automatic reference counter cedes the responsibility of memory management to compilers who use <strong>smart pointers</strong> to track the number of references to a particular instance of an object. Smart pointers are objects that simulate pointers, but also provide additional features such as reference counting or address validation.</p>

<p>The benefit of tracing garbage collection is that it is simpler to implement and does not incur any extra overhead that comes from accessing smart pointers. The downside of tracing garbage collection is that it takes a significant amount of memory to run, prevents the system from making progress while it is running, and is non-deterministic (there is no way of knowing when a object will be destructed).</p>

<p><img align="center" style="margin: 0 auto; display: block;" src="/img/os-strong-ptr.png" /></p>

<p>We implemented automatic reference counting by creating a new smart pointer type, <em>Strong Ptr</em>. Strong pointers contain pointers to a both a reference counter and the underlying object. Each time a reference to the object is created, the counter is incremented; each time a reference to the object is lost, the counter is decremented. Once the counter reaches zero, the ARC knows that there are no references to the object and, therefore, that it can safely call the object’s destructor. Below is a simple implementation of a generic strong pointer.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno">  1</span> <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="lineno">  2</span> <span class="n">class</span> <span class="n">StrongPtr</span> <span class="p">{</span>
<span class="lineno">  3</span> 	<span class="n">T</span><span class="o">*</span> <span class="n">pointer</span><span class="p">;</span>
<span class="lineno">  4</span> 	<span class="kt">int</span><span class="o">*</span> <span class="n">refs</span><span class="p">;</span>
<span class="lineno">  5</span> 
<span class="lineno">  6</span> <span class="nl">public</span><span class="p">:</span>
<span class="lineno">  7</span>     <span class="c1">// Construct a null reference</span>
<span class="lineno">  8</span>     <span class="n">StrongPtr</span><span class="p">()</span> <span class="o">:</span> <span class="n">pointer</span><span class="p">(</span><span class="n">nullptr</span><span class="p">),</span> <span class="n">refs</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)</span> <span class="p">{}</span>
<span class="lineno">  9</span> 
<span class="lineno"> 10</span>     <span class="c1">// Construct a reference to the given object</span>
<span class="lineno"> 11</span>     <span class="n">explicit</span> <span class="n">StrongPtr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span> 
<span class="lineno"> 12</span> 		<span class="n">pointer</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
<span class="lineno"> 13</span> 		<span class="k">if</span><span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 14</span> 			<span class="n">refs</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="lineno"> 15</span> 		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="lineno"> 16</span> 			<span class="n">refs</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">();</span>
<span class="lineno"> 17</span> 			<span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno"> 18</span> 		<span class="p">}</span>
<span class="lineno"> 19</span> 	<span class="p">}</span>
<span class="lineno"> 20</span> 
<span class="lineno"> 21</span> 	<span class="c1">// Reference the same object referenced by src</span>
<span class="lineno"> 22</span>     <span class="n">StrongPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">StrongPtr</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 23</span> 		<span class="n">pointer</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>
<span class="lineno"> 24</span> 		<span class="n">refs</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">refs</span><span class="p">;</span>
<span class="lineno"> 25</span> 		
<span class="lineno"> 26</span> 		<span class="k">if</span><span class="p">(</span><span class="n">refs</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span>
<span class="lineno"> 27</span> 			<span class="o">*</span><span class="n">refs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno"> 28</span> 	<span class="p">}</span>
<span class="lineno"> 29</span> 
<span class="lineno"> 30</span>     <span class="c1">// Steal the reference from src</span>
<span class="lineno"> 31</span>     <span class="n">StrongPtr</span><span class="p">(</span><span class="n">StrongPtr</span><span class="o">&amp;&amp;</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 32</span> 		<span class="n">pointer</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>
<span class="lineno"> 33</span> 		<span class="n">refs</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">refs</span><span class="p">;</span>
<span class="lineno"> 34</span> 
<span class="lineno"> 35</span> 		<span class="k">if</span><span class="p">(</span><span class="n">refs</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span>
<span class="lineno"> 36</span> 			<span class="o">*</span><span class="n">refs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno"> 37</span> 		
<span class="lineno"> 38</span> 		<span class="n">src</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="lineno"> 39</span> 	<span class="p">}</span>
<span class="lineno"> 40</span> 
<span class="lineno"> 41</span> 	<span class="c1">// Remove one reference</span>
<span class="lineno"> 42</span>     <span class="o">~</span><span class="n">StrongPtr</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno"> 43</span> 		<span class="n">reset</span><span class="p">();</span>
<span class="lineno"> 44</span> 	<span class="p">}</span>
<span class="lineno"> 45</span> 
<span class="lineno"> 46</span> 	<span class="c1">// Return the referenced object</span>
<span class="lineno"> 47</span>     <span class="n">T</span><span class="o">*</span> <span class="n">operator</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{</span>
<span class="lineno"> 48</span>         <span class="k">return</span> <span class="n">pointer</span><span class="p">;</span>
<span class="lineno"> 49</span>     <span class="p">}</span>
<span class="lineno"> 50</span> 
<span class="lineno"> 51</span> 	<span class="c1">// Check if the reference object is nullptr</span>
<span class="lineno"> 52</span> 	<span class="kt">bool</span> <span class="n">isNull</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno"> 53</span>         <span class="k">return</span> <span class="n">pointer</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="lineno"> 54</span> 	<span class="p">}</span>
<span class="lineno"> 55</span> 
<span class="lineno"> 56</span> 	<span class="c1">// Set the reference to null</span>
<span class="lineno"> 57</span> 	<span class="kt">void</span> <span class="n">reset</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno"> 58</span> 		<span class="k">if</span><span class="p">(</span><span class="n">pointer</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 59</span> 			<span class="c1">// Atomically decrement the reference count</span>
<span class="lineno"> 60</span> 			<span class="k">if</span><span class="p">(</span><span class="n">getThenIncrement</span><span class="p">(</span><span class="n">refs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 61</span> 				<span class="n">delete</span> <span class="n">pointer</span><span class="p">;</span>
<span class="lineno"> 62</span> 				<span class="n">delete</span> <span class="n">refs</span><span class="p">;</span>
<span class="lineno"> 63</span> 			<span class="p">}</span>
<span class="lineno"> 64</span> 
<span class="lineno"> 65</span> 			<span class="n">pointer</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="lineno"> 66</span> 			<span class="n">refs</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="lineno"> 67</span> 		<span class="p">}</span>
<span class="lineno"> 68</span> 	<span class="p">}</span>
<span class="lineno"> 69</span> 
<span class="lineno"> 70</span> 	<span class="c1">// Assignment, copy the src</span>
<span class="lineno"> 71</span> 	<span class="n">StrongPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">StrongPtr</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 72</span> 		<span class="n">reset</span><span class="p">();</span>
<span class="lineno"> 73</span> 
<span class="lineno"> 74</span> 		<span class="k">if</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">pointer</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 75</span> 			<span class="n">pointer</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>
<span class="lineno"> 76</span> 			<span class="n">refs</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">refs</span><span class="p">;</span>
<span class="lineno"> 77</span> 			<span class="o">*</span><span class="n">refs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno"> 78</span> 		<span class="p">}</span>
<span class="lineno"> 79</span> 
<span class="lineno"> 80</span> 		<span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="lineno"> 81</span>     <span class="p">}</span>
<span class="lineno"> 82</span> 
<span class="lineno"> 83</span> 	<span class="c1">// Assignment, steal the src</span>
<span class="lineno"> 84</span> 	<span class="n">StrongPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">operator</span> <span class="o">=</span> <span class="p">(</span><span class="n">StrongPtr</span><span class="o">&amp;&amp;</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 85</span> 		<span class="n">reset</span><span class="p">();</span>
<span class="lineno"> 86</span> 
<span class="lineno"> 87</span> 		<span class="k">if</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">pointer</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 88</span> 			<span class="n">pointer</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>
<span class="lineno"> 89</span> 			<span class="n">refs</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">refs</span><span class="p">;</span>
<span class="lineno"> 90</span> 			<span class="o">*</span><span class="n">refs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno"> 91</span> 			<span class="n">src</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="lineno"> 92</span> 		<span class="p">}</span>       
<span class="lineno"> 93</span> 
<span class="lineno"> 94</span> 		<span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="lineno"> 95</span> 	<span class="p">}</span>
<span class="lineno"> 96</span> 
<span class="lineno"> 97</span> 	<span class="c1">// Do this and other reference the same object</span>
<span class="lineno"> 98</span> 	<span class="kt">bool</span> <span class="n">operator</span> <span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">StrongPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 99</span>         <span class="k">return</span> <span class="n">pointer</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>
<span class="lineno">100</span> 	<span class="p">}</span>
<span class="lineno">101</span> 
<span class="lineno">102</span> 	<span class="c1">// Do this and other reference different objects</span>
<span class="lineno">103</span> 	<span class="kt">bool</span> <span class="n">operator</span> <span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">StrongPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">104</span>         <span class="k">return</span> <span class="n">pointer</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>
<span class="lineno">105</span> 	<span class="p">}</span>
<span class="lineno">106</span> <span class="p">};</span></code></pre></div>

<h1 id="project-5-io">Project 5: I/O</h1>

<h1 id="project-6-file-systems">Project 6: File Systems</h1>

<h1 id="project-7-virtual-memory">Project 7: Virtual Memory</h1>

<h1 id="project-8-processes-and-system-calls">Project 8: Processes and System Calls</h1>

<h1 id="project-9-file-system-calls">Project 9: File System Calls</h1>

<h1 id="project-10-shell">Project 10: Shell</h1>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno"> 1</span> <span class="kt">int</span> <span class="nf">exec</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nargs</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span> 
<span class="lineno"> 2</span> 	<span class="c1">// Lookup program in the file system. Make sure the file exists, and</span>
<span class="lineno"> 3</span> 	<span class="c1">// that it is executable (all executable ELF files begin with a</span>
<span class="lineno"> 4</span> 	<span class="c1">// special four byte sequence).</span>
<span class="lineno"> 5</span> 	<span class="n">StrongPtr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="n">file</span> <span class="o">=</span> <span class="n">kernelInfo</span><span class="o">-&gt;</span><span class="n">rootDir</span><span class="o">-&gt;</span><span class="n">lookupFile</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="lineno"> 6</span> 	<span class="k">if</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">isNull</span><span class="p">())</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="lineno"> 7</span> 	<span class="kt">char</span><span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="lineno"> 8</span> 	<span class="n">file</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="lineno"> 9</span> 	<span class="k">if</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="mh">0x7f</span> <span class="o">||</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="sc">&#39;E&#39;</span> <span class="o">||</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">!=</span><span class="sc">&#39;L&#39;</span> <span class="o">||</span> <span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">!=</span><span class="sc">&#39;F&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="lineno">10</span> 
<span class="lineno">11</span> 	<span class="c1">// Push (1) arguments onto the user stack, (2) push pointers to</span>
<span class="lineno">12</span> 	<span class="c1">// those arguments, (3) push pointer to the pointers, and (4)</span>
<span class="lineno">13</span> 	<span class="c1">// push the number of arguments onto the stack.</span>
<span class="lineno">14</span> 	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span> <span class="mh">0xffffff00</span><span class="p">;</span>
<span class="lineno">15</span> 	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">ptrs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint32_t</span><span class="p">[</span><span class="n">esp</span><span class="p">[</span><span class="mi">2</span><span class="p">]];</span>
<span class="lineno">16</span> 
<span class="lineno">17</span> 	<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nargs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">18</span> 		<span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="lineno">19</span> 		<span class="k">if</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">USERLAND</span> <span class="o">||</span> <span class="n">String</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="lineno">20</span> 		<span class="kt">uint32_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="lineno">21</span> 		<span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)((</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">base</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>
<span class="lineno">22</span> 		<span class="n">memcpy</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="lineno">23</span> 		<span class="n">ptrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">base</span><span class="p">;</span>
<span class="lineno">24</span> 	<span class="p">}</span>   
<span class="lineno">25</span> 		
<span class="lineno">26</span> 	<span class="n">base</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">nargs</span><span class="p">;</span>
<span class="lineno">27</span> 	<span class="n">memcpy</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ptrs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">nargs</span><span class="p">);</span>
<span class="lineno">28</span> 	<span class="n">base</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
<span class="lineno">29</span> 	<span class="o">*</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">nargs</span><span class="p">;</span>
<span class="lineno">30</span> 	<span class="o">*</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
<span class="lineno">31</span> 	<span class="n">switchToUser</span><span class="p">(</span><span class="n">ELF</span><span class="o">::</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">),</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">base</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
<span class="lineno">32</span> <span class="p">}</span></code></pre></div>

<h1 id="project-11-pipes-user-threads-and-exit-statuses">Project 11: Pipes, User Threads, and Exit Statuses</h1>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno"> 1</span> <span class="cp">#define PIPE_SIZE 1024</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="k">class</span> <span class="nc">Pipe</span> <span class="o">:</span> <span class="k">public</span> <span class="n">File</span> <span class="p">{</span>
<span class="lineno"> 4</span> 
<span class="lineno"> 5</span> 	<span class="n">StrongPtr</span><span class="o">&lt;</span><span class="n">BoundedBuffer</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="n">rbuf</span><span class="p">;</span>
<span class="lineno"> 6</span> 	<span class="n">StrongPtr</span><span class="o">&lt;</span><span class="n">BoundedBuffer</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="n">wbuf</span><span class="p">;</span>
<span class="lineno"> 7</span> 
<span class="lineno"> 8</span> <span class="k">public</span><span class="o">:</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> 	<span class="n">Pipe</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">11</span> 		<span class="n">rbuf</span> <span class="o">=</span> <span class="n">StrongPtr</span><span class="o">&lt;</span><span class="n">BoundedBuffer</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">BoundedBuffer</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PIPE_SIZE</span><span class="p">));</span>
<span class="lineno">12</span> 		<span class="n">wbuf</span> <span class="o">=</span> <span class="n">StrongPtr</span><span class="o">&lt;</span><span class="n">BoundedBuffer</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="lineno">13</span> 	<span class="p">}</span>
<span class="lineno">14</span> 
<span class="lineno">15</span> 	<span class="n">Pipe</span><span class="p">(</span><span class="n">Pipe</span><span class="o">*</span> <span class="n">pipe</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">16</span> 		<span class="n">rbuf</span> <span class="o">=</span> <span class="n">StrongPtr</span><span class="o">&lt;</span><span class="n">BoundedBuffer</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">BoundedBuffer</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PIPE_SIZE</span><span class="p">));</span>
<span class="lineno">17</span> 		<span class="n">wbuf</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">rbuf</span><span class="p">;</span>
<span class="lineno">18</span> 		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">rbuf</span><span class="p">;</span>
<span class="lineno">19</span> 	<span class="p">}</span>
<span class="lineno">20</span> 
<span class="lineno">21</span> 	<span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="n">getType</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">22</span> 		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="lineno">23</span> 	<span class="p">}</span>
<span class="lineno">24</span> 
<span class="lineno">25</span> 	<span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="n">getLength</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">26</span> 		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="lineno">27</span> 	<span class="p">}</span>
<span class="lineno">28</span> 
<span class="lineno">29</span> 	<span class="kt">size_t</span> <span class="n">read</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">30</span> 		<span class="k">return</span> <span class="n">readAll</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>
<span class="lineno">31</span> 	<span class="p">}</span>
<span class="lineno">32</span> 
<span class="lineno">33</span> 	<span class="kt">size_t</span> <span class="n">readAll</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">34</span> 		<span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>
<span class="lineno">35</span> 		<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbytes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="lineno">36</span> 			<span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rbuf</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
<span class="lineno">37</span> 		<span class="k">return</span> <span class="n">nbytes</span><span class="p">;</span>
<span class="lineno">38</span> 	<span class="p">}</span>
<span class="lineno">39</span> 
<span class="lineno">40</span> 	<span class="kt">size_t</span> <span class="n">write</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">41</span> 		<span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>
<span class="lineno">42</span> 		<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbytes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="lineno">43</span> 			<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">put</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="lineno">44</span> 		<span class="k">return</span> <span class="n">nbytes</span><span class="p">;</span>
<span class="lineno">45</span> 	<span class="p">}</span>
<span class="lineno">46</span> <span class="p">};</span></code></pre></div>

<h1 id="project-12-kernel-durability">Project 12: Kernel Durability</h1>

<h1 id="project-13-completely-fair-scheduler-cfs">Project 13: Completely Fair Scheduler (CFS)</h1>

<p>Cover photograph by <a href="http://9to5mac.com/2014/08/18/here-are-all-of-os-x-yosemites-beautiful-new-wallpapers/#jp-carousel-336329">9to5mac.com</a>.</p>


                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/projects/2015/11/19/compress/" data-toggle="tooltip" data-placement="top" title="Compression">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/classes/2015/12/19/cv/" data-toggle="tooltip" data-placement="top" title="Computer Vision (CS 378H)">Next Post &rarr;</a>
                    </li>
                    
                </ul>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://www.facebook.com/ashwin.madavan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/ashwin153">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; Ashwin Madavan 2016</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


</body>

</html>
